



## 3. Общее представление о запросах

Запрос представляет собой JSON объект с определенной структурой, описывающей преобразования данных из одного или несколькх источников.

Запрос описывает:
- выходные поля и выражения их формирования или вычисления;
- условия фильтрации выходных данных или данных из источников;
- идентификаторы группы для агрегации данных;
- условия сортировки, смежения и ограничения результатов.

Запрос может состоять из:
- собственно тела запроса с выражениями, функциями, операторами, полями, константами и параметрами;
- вложенные именованные запросы;
- прямых источников, указыннх в $from/$join/$union;
- подзапросов-выражений, формирующих набор или одну строку с единственным выходным полем, значение которого используется как результат выражения с запросом.

Запрос включает от одного до нескольких источников:

- $cube - абстрактный источник-куб, реальный срез-источник подбирается системой автоматически в зависимости от используемых в запросе полей и измерений в глобальном фильтре (такой источник как правило используется для финальных аналитических вычислений);
- $from:slice - источники срезы (на входе используются данные из другого среза, с учетом параметров и условий глобальной фильтрации по измерениям);
- $from:view - источники именованные запросы (запрос определенный локально в текущем запросе;
- $from:{} - запрос-однострочник с одним выходным объектом, поля которого формируются подзапросами;
- $from:{query} - источник в форме запроса;
- $union: [...] - операция упорядоченного объединения результатов из нескольких источников (друг за другом);
- $join: {...} - операция пересечения "по условию" данных из двух источников (поддерживаются INNER/LEFT/RIGHT/FULL JOIN);
- $recursive: {...} - рекурсивный обход источника;
- $provider:provider - источник исходных данных, представляющий таблицу или коллекцию БД.

## 4. Запросы к кубу и запросы к срезу

Если источником запроса является куб, тогда система выполняет автоматический выбор конкретного источника из срезов данного куба по следующим критериям в следующем порядке:

1. срез должен иметь в качестве выходных полей все поля, используемые в данном запросе;
2. срез поддерживает максимальное число измерений, используемых в глобальном фильтре;
3. срез имеет минимальную оценку времени выполнения (или вес по некоторой магической функции оценки структуры запроса).

Если источником является срез, тогда система может автоматически заменить его на другой связанный если:

1. срез связан с исходным отношением взаимозаменяемости (задается пользователем или автоматически системой);
2. срез имеет как минимум все используемые поля исходного среза;
3. срез поддерживает не меньше измерений, используемых в глобальном фильтре, чем исходный;
4. срез имеет оценку времени выполнения меньше исходного.

## 4. Запросы к внешним источникам и интеграция разных БД

Система поддерживает возможность использования различных типов и экзепляров БД в одном срезе/запросе.

В зависимости от исходных источников, типов БД, системой автоматически будет использован подходящий движок запросов, поддерживающий используемые в запросе конструкции.
Запрос может быть выполнен как целиком в одной БД, так и с использованием внутреннего интерпретатора запросов. В первом случае основная БД во время выполнения запроса будет автоматически подключаться к датакубу для получения дополнительной выборки. Во втором случае исходные данные целиком копируются в памяти системы с последующей их обработкой.

Если запрос содержит внешние источники крайне рекомендуется контролировать размер выборки (число и размер объектов) в связи с необходимостью ее копирования во время выполнения запроса. Управление ограничениями удаленных запросов можно выполнить:
- $offset + $limit в самом запросе к удаленному источнику;
- в конфигурации опция `datacube.query.engine.loopback.limit` - число строк в результирующей выборке;
- для ClickHouse: в конфигурации опция `datacube.query.engine.loopback.clickhouse.api.maxsize` - число байт в результирующей выборке.


## 5. Движок запросов

### 5.1. Общие принципы

Движок запросов представляет собой цепочку обработки запроса с целью получения результирующей выборки.

Цепочка обработки состоит из обработяиков:
- трансформаций - многоступенчатая модификация и оптимизация запроса, подготовка к трансляции под определенный тип БД;
- трансляторов - трансляция запроса к исходным Базам данных на соответствущем языке.

Цепочка/граф выполнения запроса описывается в конфигурации, в секции `datacube.query.engine.interpreters`, где каждая запись описывает один элемент цепочки "обработчик" и его конфигурацию.
Каждый обработчик может быть запущен как синхронно, так и параллельно (задается опцией async=true/false, по-умолчанию синхронно).

Конфигурация обработчика состоит из:
- поля jsb - задает имя бина с реализацией обработчика;
- поля конфигурации самого обработчика.

Главный/первый/стартовый обработчик, который используется по-умолчаниб для всех запросов, задается в конфиграциии, в опции `datacube.query.engine.start`.
Так же стартовый обработчик может быть задан при запуске запроса опцией `startEngine`.
Каждый обработчик в цепочке либо возвращает результат в виде итератора или ошибки, либо запускает другие обработчики.

Типы обработчиков (бины):
- `DataCube.Query.Engine.TransformInterpreter` - блок трансформации, последовательно выполяет несколько трансформаций, заданных в `transformers`;
- `DataCube.Query.Engine.H2Interpreter.H2InterpreterEngine` - внутренний движок-интерпретатор запросов
- `DataCube.Query.Engine.SQL.SQLTranslatorEngine` - транслятор запроса в язык SQL, вендор грамматики задается в `vendor`;
- `DataCube.Query.Engine.Mongo.MongoTranslatorInterpreter` - транслятор запроса к MongoDb с aggregate pipeline.

### 5.2. Внутренний движок-интерпретатор запросов

Внутренний движок-интерпретатор запросов используется, когда исходные источники (базы данных) не поддерживают выполнение запроса или отдельные его части, функции-операторы. Интерпретатор извлекает данные из исходных источников целиком, или усеченную/измененную выборку, используя подзапросы, после чего выполняет запрос в памяти системы.

### 5.3. Выбор итератора при нескольких вариантах выполнения запроса

По мере выполненяи запроса обработчиками может быть сформировано один или несколько итераторов одинаковых по результатам (выходным данным), но разных по способы выполнения. Например, один и тот же запрос может быть выполнен как самой БД, так и с использованием внутреннего интерпретатора; другой пример - оптимизации запроса, когда оптимизатор трансформирует запрос несколькими способами.

В конечном итоге, по завершению работы всех обработчиков, производится выбор наилучшего итератора.
В конфигурации за это отвечает секция `datacube.query.engine.iteratorSelector`.

Базовый бин, осуществляющий выбор итератора `DataCube.Query.Engine.IteratorSelector` позволяет выбрать одну из следующих стратегий выбора:
- `method = selectFirst`             - выбирает итератор первый по порядку;
- `method = selectRandom`            - каждый раз выбирает произвольный итератор;
- `method = selectBestEstimationTime`- выбирает согласно внутренней оценочной функции;
- `method = selectExecutedFirst`     - выбирает итератор, который первый вернет результат (запускаются все варианты и ожидается первый элемент результирующей выборки);
- `method = selectByEnginePriority`  - выбирает итератор по обработчику и таблице приоритетов (опция`selectByEnginePriority_defaultPriority` задает приоритет по-умолчаниюб, опция `selectByEnginePriority_selectByEnginePriority` - таблицу приоритетов);
- `method = selectVendorsOrder`      - выбирает по приоритету типа БД (вендору; порядок/приоритет задается опцией `selectVendorsOrder_vendorsOrder`).

### 5.4. Работа анализатора - $analyze:true


## 6. ...

## 7. Язык запросов

### 7.1 Структура

Общая схема любого запроса:
<pre>
{
    $select:       - задает выходные поля

    $filter:       - опционально: задает условия фильтрации по полями источников
    $postFilter:   - опционально: задает условия фильтрации по выходным полям
    $globalFilter: - опционально: задает условия глобальной фильтрации по измерениям
    
    $distinct:     - опционально: указывает на необходимость отфильтровать дубли
    $groupBy:      - опционально: задает идентификатор группы
    $sort:         - опционально: задает условия сортировки
    
    $offset:       - опционально: пропуск результатов
    $limit:        - опционально: ограничение результата
    
    $from/$join/$union/$recursive/$provider/$cube: - источник текущего запроса
    
    $context:      - опционально: задает имя контекста текущего запроса (связан с полями источников данного запроса)
    
    $params:       - опционально: определение параметров и значений по-умолчанию
    
    $views:        - опционально: локальные именованные запросы
}
</pre>


Пример запроса:
```
{
    $select: {
        "Код отрасли": {$group: {$toInt: "Код отрасли"}},
        "Число показателей отрасли": {$sum:1},
        "Сумма показателей отрасли": {$sum: {$toDouble: "Значение"}},
        "Число отраслей": {$gcount: {$distinct: "Код отрасли"}},
        "Максимальная сумма показателей отрасли": {$grmaxsum: {$toDouble: "Значение"}},
    },
    $postFilter: {
        "Сумма показателей" : {$gt: {$const:0}}
    },
    $from: "source_slice"
}
```

### 7.2 Определение выходных полей - $select

### 7.3 Параметры, определение и значения по-умолчанию - $params

Задается в запросе, когда необходимо определить используемые в текущем запросе или во внутренних запросах параметров. Так же может использоваться для переопределения значения по умолчанию параметра с таким же названием, определенного и использованного во внутренних запросах и срезах.

Имя параметра всегда задается в формате `"${имя параметра}"` и при определениии и при использовании.

Общая схема выражения определения параметров запроса:
```
$params: {
    "${имя параметра}": {
        $type:              - задает тип параметра
        $nativeType:        - задает тип параметра в формате БД
        $defaultValue:      - задает значение по-умолчанию
    },
}
```

Пример запроса:
```
{
    $params: {
        "${val1}": {
            $type: 'string',
            $defaultValue: {$const: '0.00'}
        },
        "${val2}": {
            $type: 'integer',
            $defaultValue: {$const: 0}
        }
    },
    $select: {
        "Код отрасли": {$group: {$toInt: "Код отрасли"}},
        "Сумма показателей отрасли": {$sum: {$toDouble: "Значение"}},
        "Максимальная сумма показателей отрасли": {$grmaxsum: {$toDouble: "Значение"}},
    },
    $filter: {
        $ne: [
            {$field: "Код отрасли"},
            "${val1}"
        ]
    },
    $from: "source_slice_with_param_${val2}"
}
```


### 7.4 Фильтрация по полям источника - $filter

### 7.5 Фильтрация по выходным полям - $postFilter

### 7.6 Глобальная фильтрация по измерениям - $globalFilter

### 7.7. Группировка и агрегация
#### 7.7.1. Функция определения идентификатора группы - $group
#### 7.7.2. Функции агрегации
#### 7.7.3. Удаление дублей - $distinct
#### 7.7.4. Прямое определение идентификатора группы - $groupBy
#### 7.7.5. Функции глобальной агрегации - $g*
#### 7.7.6. Функции глобальной агрегации над группами - $gr*

### 7.8. Сортировка - $sort

### 7.9. Фильтрация дублей - $distinct:true

### 7.10. Смещение и ограничение результатов - $limit, $offset

### 7.11. Глобальные подзапросы-выражения

### 7.12. Связанные подзапросы-выражения

### 7.13. Пересечение - $join

### 7.14. Объединение - $union

### 7.15. Рекурсия - $recursive

### 7.16. Встроенные и внешние типы данных - $type, $nativeType

### 7.17. Работа со строками

### 7.18. Математические операторы

### 7.19. Дата и время

### 7.20. Преобразование типов - $to*

### 7.21. Поля единственного источника - $field

### 7.22. Поля указанного источника - $field, $sourceContext

### 7.23. Внешние поля контекста родительского запроса - $field, $context

### 7.24. Константы - $const

