## Set start engine alias that used in Query.execute
datacube.query.engine.start = start

## Set bean and method that used for select iterator that returned by engines
datacube.query.engine.iteratorSelector = {
  jsb = DataCube.Query.Engine.IteratorSelector

  #method = selectFirst
  #method = selectRandom
  #method = selectBestEstimationTime
  #method = selectExecutedFirst

  method = selectByEnginePriority
  defaultEnginePriority = 5
  enginesPriority = {
    SQLPostgres   = 100
    SQLClickHouse = 200
    SQLDefault    = 50
    Mongo         = 100
    H2Interpreter = 10
  }

  #method = selectVendorsOrver
  #vendorsOrder = [ClickHouse, PostgreSQL]
}

## Set engines aliased and execution pipeline-trees (link options: next, remoteStart)
datacube.query.engines = {
  start = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      PrepareSQL,
      PrepareMongo,
      #PrepareH2Interpreter,
    ]
  },
  startWithoutH2Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      PrepareSQL,
      PrepareMongo,
    ]
  },

  PrepareSQL = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.OrderQueryViews,
      #DataCube.Query.Transforms.EmbedViewQueries,
      #DataCube.Query.Transforms.DefineContexts,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      SQLPostgres,
      PrepareSQLClickHouse,
      SQLDefault,
    ]
  },
  SQLPostgres = {
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = PostgreSQL
  },
  PrepareSQLClickHouse = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViewQueries,
      DataCube.Query.Transforms.DefineContexts,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      SQLClickHouse,
    ]
  },
  SQLClickHouse = {
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = ClickHouse
    remoteStart = start
  },
  SQLDefault = {
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = H2
    remoteStart = start
  },

  PrepareMongo = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
      DataCube.Query.Transforms.EmbedViewQueries,
      ## добавить/обновить названия контекстов запросов
      DataCube.Query.Transforms.DefineContexts,
      ## вынести глобальные вложенные запросы в запрос-обертку
      DataCube.Query.Transforms.WrapGlobalSubQueries,
    ]
    next = [
      Mongo,
    ]
  },
  Mongo = {
    jsb = DataCube.Query.Engine.Mongo.MongoTranslatorEngine
  },

  PrepareH2Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
      DataCube.Query.Transforms.EmbedViewQueries,
      ## добавить/обновить названия контекстов запросов
      DataCube.Query.Transforms.DefineContexts,
    ]
    next = [
      H2Interpreter,
    ]
  },
  H2Interpreter = {
    alias = H2Interpreter
    jsb = DataCube.Query.Engine.H2Interpreter.H2InterpreterEngine,
    remoteStart = startWithoutH2Interpreter
  },

}


## Set query transformation pipeline (used by TransformEngine in start, startWithoutH2Interpreter)
datacube.query.transformers = [
  ## построение тела запроса (встраивание "самых легких" подходящих срезов вместо $from/$cube)
  DataCube.Query.Transforms.AssemblyQueryBody,

  ## приведение контекстов и названий в $views к равенству
  DataCube.Query.Transforms.NormalizeViewsContext,

  ## встроить $globalFilter во все запросы к кубу
  DataCube.Query.Transforms.PropagateGlobalFilter,

  ## заменить алиасы представляющие поля куба "как есть"
  DataCube.Query.Transforms.PatchDirectFieldsAliases,

  ## пребразование $postFilter - обернуть оригинальный запрос запросом с фильтром
  DataCube.Query.Transforms.UnwrapPostFilter,

  DataCube.Query.Transforms.GenerateGroupBy,

//    ## добавить/обновить названия контекстов запросов
//    DataCube.Query.Transforms.DefineContexts,

  ## развернуть сложные операторы - подставить выражения
  DataCube.Query.Transforms.UnwrapComplexOperators,

  ## производит патчинг контекстов полей запросов с $join источником - $context заменяет на $sourceContext
  DataCube.Query.Transforms.PatchJoinFields,

  ## заменяет контекст полей, когда он задан заведомо неправильно
  DataCube.Query.Transforms.PatchBadContext,

  ## упорядочить $select и добавить $groupBy, если есть глобальная агрегация
  DataCube.Query.Transforms.OrderSelect,
  ## привести фильтры к единому стилю
  DataCube.Query.Transforms.NormalizeFilters,
  ## привести сортировку к единому стилю
  DataCube.Query.Transforms.NormalizeSort,

  DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedSimpleViews,

  ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
//  DataCube.Query.Transforms.EmbedViewQueries,

  ## добавить/обновить названия контекстов запросов
  DataCube.Query.Transforms.DefineContexts,

  #    ## объединить одинаковые запросы и вынести во вьюхи
  #    "DataCube.Query.Transforms.NestedQueryOptimization",
//    ## оптиизация фильтров - вынесение условий ближе к первичным источникам (ближе к индексам БД)
//    DataCube.Query.Transforms.PropagateSourceFilters,
  DataCube.Query.Transforms.OptimizeFields,
]

datacube.query.transformer.config.embedSimpleViews = {
  embedDirectProviders=true
  embedDirectQueries=true
  embedSingleUsedViews=true
  embedAll=false
}

datacube.query.accelerators = [
  DataCube.Query.Accelerator.QuerySplitterAccelerator,
]




