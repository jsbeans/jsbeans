datacube.query.trace.enabled = true

datacube.query.engine.start = start

datacube.query.engine.selector = {
  jsb = DataCube.Query.Engine.IteratorSelector

  #method = selectFirst
  #method = selectRandom
  #method = selectBestEstimationTime
  #method = selectExecutedFirst

  method = selectByEnginePriority
  defaultEnginePriority = 5
  enginesPriority = {
    SQLPostgres   = 100
    SQLClickHouse = 200
    SQLDefault    = 50
    Mongo         = 100
    H2Interpreter = 1000
  }

  #method = selectVendorsOrver
  #vendorsOrder = [ClickHouse, PostgreSQL]
}

datacube.query.engines = {
  start = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      PrepareSQL,
      PrepareMongo,
      PrepareH2Interpreter,
    ]
  },
  PrepareSQL = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.OrderQueryViews,
      DataCube.Query.Transforms.EmbedViewQueries,
      DataCube.Query.Transforms.DefineContexts,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      SQLPostgres,
      PrepareSQLClickHouse,
      SQLDefault,
    ]
  },
  SQLPostgres = {
    jsb = DataCube.Query.Engine.SQLTranslatorEngine
    vendor = PostgreSQL
  },
  PrepareSQLClickHouse = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViewQueries,
      DataCube.Query.Transforms.DefineContexts,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      SQLClickHouse,
    ]
  },
  SQLClickHouse = {
    jsb = DataCube.Query.Engine.SQLTranslatorEngine
    vendor = ClickHouse
  },
  SQLDefault = {
    jsb = DataCube.Query.Engine.SQLTranslatorEngine
    vendor = H2
  },
  PrepareMongo = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
      DataCube.Query.Transforms.EmbedViewQueries,
      ## добавить/обновить названия контекстов запросов
      DataCube.Query.Transforms.DefineContexts,
      ## вынести глобальные вложенные запросы в запрос-обертку
      DataCube.Query.Transforms.WrapGlobalSubQueries,
    ]
    next = [
      Mongo,
    ]
  },
  Mongo = {
    jsb = DataCube.Query.Engine.MongoTranslatorEngine
  },
  PrepareH2Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
      DataCube.Query.Transforms.EmbedViewQueries,
      ## добавить/обновить названия контекстов запросов
      DataCube.Query.Transforms.DefineContexts,
    ]
    next = [
      H2Interpreter,
    ]
  },
  H2Interpreter = {
    alias = H2Interpreter
    jsb = DataCube.Query.Engine.H2InterpreterEngine,
    next = remote
  },
  remote = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      PrepareSQL,
      PrepareMongo,
    ]
  },
}


# если true, то транслироваться будут только запросы к провадерам, если false - будет попытка транслировать запрос целиком
datacube.query.translator.skipQueries.enabled = false

# Если true, то запуск запроса транслятором осуществляется при первом next(), если false - при построении итератора
datacube.query.translator.lazy.enabled = true

datacube.query.transformers = [
  ## построение тела запроса (встраивание "самых легких" подходящих срезов вместо $from/$cube)
  "DataCube.Query.Transforms.AssemblyQueryBody",

  ## приведение контекстов и названий в $views к равенству
  "DataCube.Query.Transforms.NormalizeViewsContext",

  ## встроить $globalFilter во все запросы к кубу
  "DataCube.Query.Transforms.PropagateGlobalFilter",

  ## заменить алиасы представляющие поля куба "как есть"
  "DataCube.Query.Transforms.PatchDirectFieldsAliases",

  ## пребразование $postFilter - обернуть оригинальный запрос запросом с фильтром
  "DataCube.Query.Transforms.UnwrapPostFilter",

//    ## добавить/обновить названия контекстов запросов
//    "DataCube.Query.Transforms.DefineContexts",

  ## развернуть сложные операторы - подставить выражения
  "DataCube.Query.Transforms.UnwrapComplexOperators",

  ## упорядочить $select и добавить $groupBy, если есть глобальная агрегация
  "DataCube.Query.Transforms.OrderSelect",
  ## привести фильтры к единому стилю
  "DataCube.Query.Transforms.NormalizeFilters",
  ## привести сортировку к единому стилю
  "DataCube.Query.Transforms.NormalizeSort",

  ## встроить тела вьюх в запрос - требуется, т.к. у всех запросов должны быть уникальные контексты
//    "DataCube.Query.Transforms.EmbedViewQueries",

  ## добавить/обновить названия контекстов запросов
  "DataCube.Query.Transforms.DefineContexts",

  #    ## объединить одинаковые запросы и вынести во вьюхи
  #    "DataCube.Query.Transforms.NestedQueryOptimization",
//    ## оптиизация фильтров - вынесение условий ближе к первичным источникам (ближе к индексам БД)
//    "DataCube.Query.Transforms.PropagateSourceFilters",
]

datacube.query.accelerators = [
  "DataCube.Query.Accelerator.QuerySplitterAccelerator",
]




