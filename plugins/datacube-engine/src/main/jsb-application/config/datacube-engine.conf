
## Set bean and method that used for select iterator that returned by engines
datacube.query.engine.iteratorSelector = {
  jsb = DataCube.Query.Engine.IteratorSelector

  #method = selectFirst
  #method = selectRandom
  #method = selectBestEstimationTime
  #method = selectExecutedFirst

  method = selectByEnginePriority
  selectByEnginePriority_defaultPriority = 5
  selectByEnginePriority_selectByEnginePriority = {
    Execute/ClickHouse  = 300
    Execute/Postgres    = 200
    Execute/H2          = 100
    Execute/Mongo       = 100
    Execute/Interpreter = 10
  }

  #method = selectVendorsOrder
  #selectVendorsOrder_vendorsOrder = [ClickHouse, PostgreSQL]
}

## Set start engine alias that used in Query.execute
datacube.query.engine.start   = START/Main
datacube.query.engine.prepare = START/Save

## Set engines aliased and execution pipeline-trees (link options: next, loopbackStart)
datacube.query.engines = {

  ## prepare query before save (for faster exection)
  START/Save = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers.save
    next = [
      ReturnQuery,
    ]
  }

  START/Main = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers.main
    next = [
      Prepare/SQL,
      Prepare/Mongo,
      Prepare/Interpreter,
    ]
  },
  START/FromInterpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers.main
    next = [
      Prepare/SQL,
      Prepare/Mongo,
    ]
  },

  Prepare/SQL = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.OrderQueryViews,
      //DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/Postgres,
      Prepare/ClickHouse,
      Execute/H2,
    ]
  },

  Prepare/Mongo = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      //DataCube.Query.Transforms.SimplyContexts,
      DataCube.Query.Transforms.WrapGlobalSubQueries, // TODO: по возможности ускорить
    ]
    next = [
      Execute/Mongo,
    ]
  },

  Prepare/Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      //DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/Interpreter,
    ]
  },
  
  Prepare/ClickHouse = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      //DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/ClickHouse,
    ]
  },

  Execute/Postgres = {
    #async = true
    #jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    jsb = DataCube.Query.Engine.SQL.SQLStoreEngine
    vendor = PostgreSQL
  },
  
  Execute/ClickHouse = {
    #async = true
    #jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    jsb = DataCube.Query.Engine.SQL.SQLStoreEngine
    vendor = ClickHouse
    loopbackStart = START/Main
  },
  
  Execute/H2 = {
    #async = true
    #jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    jsb = DataCube.Query.Engine.SQL.SQLStoreEngine
    vendor = H2
    excludeVendors = [ClickHouse, PostgreSQL]
    loopbackStart = START/Main
  },
  
  Execute/Mongo = {
    #async = true
    jsb = DataCube.Query.Engine.Mongo.MongoTranslatorEngine
  },

  Execute/Interpreter = {
    #async = true
    #jsb = DataCube.Query.Engine.H2Interpreter.H2InterpreterEngine,
    jsb = DataCube.Query.Engine.SQL.InMemoryEngine
    loopbackStart = START/FromInterpreter
    inMemory = true
  },

  ReturnQuery = {
    jsb = DataCube.Query.Engine.ReturnQueryEngine
  }

}


## Set query transformation pipeline (used by TransformEngine in start, START/FromInterpreter)
datacube.query.transformers.save = [
  DataCube.Query.Transforms.NormalizeViewsContext,
  DataCube.Query.Transforms.PatchDirectFieldsAliases,
  DataCube.Query.Transforms.GenerateGroupBy,
  DataCube.Query.Transforms.UnwrapComplexOperators,
  DataCube.Query.Transforms.PatchJoinFields,
  DataCube.Query.Transforms.PatchBadContext,
  DataCube.Query.Transforms.OrderSelect,
  DataCube.Query.Transforms.NormalizeFilters,
  DataCube.Query.Transforms.NormalizeSort,
  DataCube.Query.Transforms.DefineContexts,
]

datacube.query.transformers.main = [
  ## построение тела запроса (встраивание "самых легких" подходящих срезов вместо $from/$cube)
  DataCube.Query.Transforms.AssemblyQueryBody,

  ## приведение контекстов и названий в $views к равенству
  DataCube.Query.Transforms.NormalizeViewsContext,

  ## встроить $globalFilter во все запросы к кубу
  DataCube.Query.Transforms.PropagateGlobalFilter,

  ## заменить алиасы представляющие поля куба "как есть"
  DataCube.Query.Transforms.PatchDirectFieldsAliases, // TODO: по возможности ускорить

  ## пребразование $postFilter - обернуть оригинальный запрос запросом с фильтром
  DataCube.Query.Transforms.UnwrapPostFilter,

  DataCube.Query.Transforms.GenerateGroupBy,

//    ## добавить/обновить названия контекстов запросов
//    DataCube.Query.Transforms.DefineContexts,

  ## развернуть сложные операторы - подставить выражения
  DataCube.Query.Transforms.UnwrapComplexOperators,

  ## производит патчинг контекстов полей запросов с $join источником - $context заменяет на $sourceContext
  DataCube.Query.Transforms.PatchJoinFields,

  ## заменяет контекст полей, когда он задан заведомо неправильно
  DataCube.Query.Transforms.PatchBadContext,

  ## упорядочить $select и добавить $groupBy, если есть глобальная агрегация
  DataCube.Query.Transforms.OrderSelect, // TODO по возможности ускорить
  ## привести фильтры к единому стилю
  DataCube.Query.Transforms.NormalizeFilters,
  ## привести сортировку к единому стилю
  DataCube.Query.Transforms.NormalizeSort,

  DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedSimpleViews,

//  DataCube.Query.Transforms.EmbedViewQueries,

  ## добавить/обновить названия контекстов запросов
  DataCube.Query.Transforms.DefineContexts,

  #    ## объединить одинаковые запросы и вынести во вьюхи
  #    "DataCube.Query.Transforms.NestedQueryOptimization",
//    ## оптиизация фильтров - вынесение условий ближе к первичным источникам (ближе к индексам БД)
//    DataCube.Query.Transforms.PropagateSourceFilters,
  DataCube.Query.Transforms.OptimizeFields,

  DataCube.Query.Transforms.SimplyContexts,
]

datacube.query.transformer.config.embedSimpleViews = {
  embedDirectProviders=true
  embedDirectQueries=true
  embedSingleUsedViews=true
  embedAll=false
}
datacube.query.transformer.config.embedAllViews = {
  embedAll=true
}

//datacube.query.accelerators = [
//  DataCube.Query.Accelerator.QuerySplitterAccelerator,
//]




