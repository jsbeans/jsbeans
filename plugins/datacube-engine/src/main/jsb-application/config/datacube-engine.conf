
## Set bean and method that used for select iterator that returned by engines
datacube.query.engine.iteratorSelector = {
  jsb = DataCube.Query.Engine.IteratorSelector

  #method = selectFirst
  #method = selectRandom
  #method = selectBestEstimationTime
  #method = selectExecutedFirst

  method = selectByEnginePriority
  selectByEnginePriority_defaultPriority = 5
  selectByEnginePriority_selectByEnginePriority = {
    Execute/ClickHouse = 300
    Execute/Postgres   = 200
    Execute/H2    = 100
    Execute/Mongo          = 100
    Execute/Interpreter    = 10
  }

  #method = selectVendorsOrder
  #selectVendorsOrder_vendorsOrder = [ClickHouse, PostgreSQL]
}

## Set start engine alias that used in Query.execute
datacube.query.engine.start = START/Main

## Set engines aliased and execution pipeline-trees (link options: next, loopbackStart)
datacube.query.engines = {
  START/Main = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      Prepare/SQL,
      Prepare/Mongo,
      #Prepare/Interpreter,
    ]
  },
  START/Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = datacube.query.transformers
    next = [
      Prepare/SQL,
      Prepare/Mongo,
    ]
  },

  Prepare/SQL = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.OrderQueryViews,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/Postgres,
      Prepare/ClickHouse,
      Execute/H2,
    ]
  },

  Prepare/Mongo = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      DataCube.Query.Transforms.SimplyContexts,
      DataCube.Query.Transforms.WrapGlobalSubQueries,
    ]
    next = [
      Execute/Mongo,
    ]
  },

  Prepare/Interpreter = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/Interpreter,
    ]
  },
  
  Prepare/ClickHouse = {
    jsb = DataCube.Query.Engine.TransformEngine
    transformers = [
      DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedAllViews,
      DataCube.Query.Transforms.SimplyContexts,
    ]
    next = [
      Execute/ClickHouse,
    ]
  },

  Execute/Postgres = {
    async = true
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = PostgreSQL
  },
  
  Execute/ClickHouse = {
    async = true
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = ClickHouse
    loopbackStart = START/Main
  },
  
  Execute/H2 = {
    async = true
    jsb = DataCube.Query.Engine.SQL.SQLTranslatorEngine
    vendor = H2
    loopbackStart = START/Main
  },
  
  Execute/Mongo = {
    async = true
    jsb = DataCube.Query.Engine.Mongo.MongoTranslatorEngine
  },

  Execute/Interpreter = {
    async = true
    jsb = DataCube.Query.Engine.H2Interpreter.H2InterpreterEngine,
    loopbackStart = START/Interpreter
  },

}


## Set query transformation pipeline (used by TransformEngine in start, START/Interpreter)
datacube.query.transformers = [
  ## построение тела запроса (встраивание "самых легких" подходящих срезов вместо $from/$cube)
  DataCube.Query.Transforms.AssemblyQueryBody,

  ## приведение контекстов и названий в $views к равенству
  DataCube.Query.Transforms.NormalizeViewsContext,

  ## встроить $globalFilter во все запросы к кубу
  DataCube.Query.Transforms.PropagateGlobalFilter,

  ## заменить алиасы представляющие поля куба "как есть"
  DataCube.Query.Transforms.PatchDirectFieldsAliases,

  ## пребразование $postFilter - обернуть оригинальный запрос запросом с фильтром
  DataCube.Query.Transforms.UnwrapPostFilter,

  DataCube.Query.Transforms.GenerateGroupBy,

//    ## добавить/обновить названия контекстов запросов
//    DataCube.Query.Transforms.DefineContexts,

  ## развернуть сложные операторы - подставить выражения
  DataCube.Query.Transforms.UnwrapComplexOperators,

  ## производит патчинг контекстов полей запросов с $join источником - $context заменяет на $sourceContext
  DataCube.Query.Transforms.PatchJoinFields,

  ## заменяет контекст полей, когда он задан заведомо неправильно
  DataCube.Query.Transforms.PatchBadContext,

  ## упорядочить $select и добавить $groupBy, если есть глобальная агрегация
  DataCube.Query.Transforms.OrderSelect,
  ## привести фильтры к единому стилю
  DataCube.Query.Transforms.NormalizeFilters,
  ## привести сортировку к единому стилю
  DataCube.Query.Transforms.NormalizeSort,

  DataCube.Query.Transforms.EmbedViews~datacube.query.transformer.config.embedSimpleViews,

//  DataCube.Query.Transforms.EmbedViewQueries,

  ## добавить/обновить названия контекстов запросов
  DataCube.Query.Transforms.DefineContexts,

  #    ## объединить одинаковые запросы и вынести во вьюхи
  #    "DataCube.Query.Transforms.NestedQueryOptimization",
//    ## оптиизация фильтров - вынесение условий ближе к первичным источникам (ближе к индексам БД)
//    DataCube.Query.Transforms.PropagateSourceFilters,
  #DataCube.Query.Transforms.OptimizeFields,
]

datacube.query.transformer.config.embedSimpleViews = {
  embedDirectProviders=true
  embedDirectQueries=true
  embedSingleUsedViews=true
  embedAll=false
}
datacube.query.transformer.config.embedAllViews = {
  embedAll=true
}

//datacube.query.accelerators = [
//  DataCube.Query.Accelerator.QuerySplitterAccelerator,
//]




