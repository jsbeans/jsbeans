# jsBeans - Client-server JavaScript Fullstack  Web Framework
  
 ```jsBeans``` — клиент-серверный веб-фреймворк класса "full-stack" для создания веб-приложений на языке JavaScript. Реализован на Java 1.8 с Mozilla Rhino в качестве серверного JavaScript движка, встроенным Web сервером на Eclipse Jetty и сервисной шиной на Akka.
 
 Может использоваться:
 1. В виде самостоятельного сервера приложений с развертыванием прикладных приложений "из папки".
 2. В виде подключаемой Java библиотеки. Прикладные модули как правило так же подключаются в общий classpath основного приложения.
 
 Ключевые фитчи "из коробки":
 * ```JavaScript Bean (JSB)``` - изоморфные объекты-классы, включающие $server, $client и $common части.
 * Базовые концепции ООП поверх JavaScript
 * Прозрачное взаимодействие частей бина и автоматическая синхронизация данных на единой RPC шине, оптимизирующей Ajax запросы при синхронизации большого числа бинов 
 * Дескриптор бина (JSON с функциями) представляет логически законченный функциональный компонент и одновременно содержит клиенсткий и серверный код
 * Шаблонизатор ```/*#dot{{...}}#*/``` (сейчас ```#dot{{...}}```)
 * Поддержка пакетов, управление зависимостями
 * Базовая библиотека системных бинов
 * Базовая библиотека бинов виджетов
 * Публикация методов бина в HTTP JSON API
 * Расширения бинов, позволяющие повесить на бины дополнительный базовый функционал
 * Динамическая отложенная загрузка допонительных бинов с сервера на клиент
 * Минификатор и упаковщик

 * TODO
 * TODO

# Самый простой бин

```javascript
JSB({
    $name: 'MyBean',
    
    myFiled: 123,
    
    myMethod: function(){
        return this.myField;
    }    
});
```

# Клиент-серверный бин с тремя секциями - общая базовая ($common), $server, $client

```javascript
JSB({
    /** пакет и имя бина */
    $name: 'my.examples.MyBean',
    
    /** бин может наследовать свойства и методы родительского */
    $parent: 'my.examples.ParentBean',
     
    /** бин может импортировать другие бины (например, для создания экземпляров), типы импортированных бинов будут интегрированы в scope методов */
    $require: {MyWorld: 'my.examples.MyWorld'},
     
    /** поля, объявленные в общей секции синхронизируются и могут использоваться в $client и $server прозрачно (производится слияние изменений)*/
    myField: {}, /// common fields changes would be synchronized both $client and $server
    
    /** методы из общей секции могут использоваться (копируются) в $client и $server*/
    getMessageText: function(){
        var text = '';
        for (let p: this.myMessage) if (this.myMessage.hasOwnProperty(p)) {
            return p + ' = ' + this.myMessage.text + '\n';
        }
        return text;
    },

    /** секция серверного кода (исполняется на сервере)*/
    $server: {
        /** серверный конструктор вызывается при порождении серверной части экземпляра бина */
        $constructor: function(){
            /** создание экземпляра импортированного бина */
            this.myWorld = new MyWorld();
            /** в scope всех методов добавляется $this равный this, чтобы перед вложенными функциями не декларировать 'var self = this' */
            $this.say('Hello');                            
        },
        /** методы, объявленные в серверной секции могут вызываться с клиента и наоборот */
        say: function (text){
            /** изменение значения поля из общей секции будет синхронизировано с клиентом и в $client this.myFiled будет обновлено */
            this.myFiled.serverText = this.getTimestamp() + ': Server say ' + text + '!';
        },
        /** В серверной секции так же можно использовать java классы и объекты, добавив префикс 'Packages.' */
        getTimestamp: function() {
            return 0 + Packages.java.lang.System.currentTimeMillis();
        }
    },

    /** секция клиентского кода (исполняется в браузере)*/
    $client: {
        $constructor: function(){          
            
            window.setInterval(function(){
                /** вызов метода из "противоположной секции" осуществляется асинхронно через адаптер*/
                $server.getTimestamp(function(){                    
                    /** getMessageText при создании был скопирован из общей секции, поэтому использовает значение this.myFiled на клиенте */
                    alert($this.getMessageText());
                });                
            }, 1000)
        }
    },
    
});
```

# Web виджет
* TODO

# Web приложение
* TODO

# Управление жизненным циклом
Бин является составным объектом, разные его части (клиентская и серверная) имеют различные JavaScript объекты, у каждого может быть свой жизненный цикл и область видимости. Разработчик может привязать жизненный цикл бина к сесии пользователя, управлять автопорождением экземпляров или управлять жизненным циклом вручную. Ниже приведено несколько часто используемых случаев. 

## Синглтон 
* TODO

## Синглтон в рамках сессии
* TODO

## Автопорождение серверной части с клиента
* TODO

## Один бин: один клиентский - один серверный
* TODO

## Один бин: много клиентский - один серверный
* TODO

## Один бин: много клиентский - много серверных
* TODO


  